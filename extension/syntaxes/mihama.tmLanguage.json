{
  "scopeName": "source.mihama",
  "fileTypes": [
    "mh"
  ],
  "patterns": [
    {
      "include": "#comments"
    },
    {
      "include": "#directives"
    },
    {
      "include": "#strings"
    },
    {
      "include": "#numbers"
    },
    {
      "include": "#keywords"
    },
    {
      "include": "#preprocessor"
    },
    {
      "include": "#generics"
    },
    {
      "include": "#import_export"
    },
    {
      "include": "#type_declaration"
    },
    {
      "include": "#struct_class"
    },
    {
      "include": "#let_declaration"
    },
    {
      "include": "#lambda_expression"
    },
    {
      "include": "#function_call"
    },
    {
      "include": "#pattern_matching"
    },
    {
      "include": "#module_access"
    },
    {
      "include": "#infix_operator"
    },
    {
      "include": "#identifiers"
    }
  ],
  "repository": {
    "comments": {
      "patterns": [
        {
          "name": "comment.line.double-slash.ma",
          "match": "//.*$"
        },
        {
          "name": "comment.block.ma",
          "begin": "/\\*",
          "end": "\\*/"
        },
        {
          "name": "comment.doc.ma",
          "begin": "///",
          "end": "$"
        }
      ]
    },
    "directives": {
      "patterns": [
        {
          "name": "meta.directive.import.ma",
          "match": "@import\\s+\"[^\"\\\\]*(?:\\\\.[^\"\\\\]*)*\"",
          "captures": {
            "0": {
              "name": "keyword.directive.import.ma"
            }
          }
        },
        {
          "name": "meta.directive.import_noquote.ma",
          "match": "@import\\s+[^\\s]+",
          "captures": {
            "0": {
              "name": "keyword.directive.import.ma"
            }
          }
        }
      ]
    },
    "preprocessor": {
      "patterns": [
        {
          "name": "meta.preprocessor.define.ma",
          "match": "@define\\s+([A-Za-z_][A-Za-z0-9_]*)\\s+([^\\n]+)",
          "captures": {
            "1": {
              "name": "variable.other.preprocessor.name.ma"
            },
            "2": {
              "name": "constant.numeric.preprocessor.value.ma"
            }
          }
        },
        {
          "name": "meta.preprocessor.macro.ma",
          "begin": "@macro\\s+([A-Za-z_][A-Za-z0-9_]*)(?:\\s*\\(([^)]*)\\))?\\s*=>",
          "beginCaptures": {
            "1": {
              "name": "entity.name.function.macro.ma"
            },
            "2": {
              "name": "variable.parameter.macro.ma"
            }
          },
          "end": "(?=$)",
          "patterns": [
            {
              "include": "#lambda_expression"
            },
            {
              "include": "#identifiers"
            }
          ]
        },
        {
          "name": "meta.preprocessor.conditional.ma",
          "begin": "(?x)@(?:(ifdef|ifndef))\\s+([A-Za-z_][A-Za-z0-9_]*)",
          "beginCaptures": {
            "1": {
              "name": "keyword.control.preprocessor.ma"
            },
            "2": {
              "name": "variable.other.preprocessor.name.ma"
            }
          },
          "end": "(?x)@endif",
          "patterns": [
            {
              "include": "#directives"
            },
            {
              "include": "#strings"
            },
            {
              "include": "#numbers"
            },
            {
              "include": "#let_declaration"
            },
            {
              "include": "#type_declaration"
            },
            {
              "include": "#struct_class"
            },
            {
              "include": "#pattern_matching"
            }
          ]
        }
      ]
    },
    "strings": {
      "patterns": [
        {
          "name": "string.quoted.double.ma",
          "begin": "\"",
          "end": "\"",
          "patterns": [
            {
              "name": "constant.character.escape.ma",
              "match": "\\\\."
            }
          ]
        },
        {
          "name": "string.quoted.single.ma",
          "begin": "'",
          "end": "'",
          "patterns": [
            {
              "name": "constant.character.escape.ma",
              "match": "\\\\."
            }
          ]
        }
      ]
    },
    "numbers": {
      "patterns": [
        {
          "name": "constant.numeric.float.ma",
          "match": "\\b\\d+\\.\\d+\\b"
        },
        {
          "name": "constant.numeric.integer.ma",
          "match": "\\b\\d+\\b"
        }
      ]
    },
    "keywords": {
      "patterns": [
        {
          "name": "keyword.control.ma",
          "match": "\\b(import|as|type|export|abstract|let|match|if|then|else|in|struct|class|trait|impl|priv|true|false|null)\\b"
        }
      ]
    },
    "operators": {
      "patterns": [
        {
          "name": "keyword.operator.lambda.ma",
          "match": "=>|->"
        },
        {
          "name": "keyword.operator.math.ma",
          "match": "\\+\\+|\\+|-|\\*|\\/|%|\\^"
        },
        {
          "name": "keyword.operator.comparison.ma",
          "match": "==|!=|>=|<=|>|<"
        },
        {
          "name": "keyword.operator.logical.ma",
          "match": "&&|\\|\\|"
        },
        {
          "name": "keyword.operator.assignment.ma",
          "match": "="
        },
        {
          "name": "keyword.operator.path.ma",
          "match": "::"
        },
        {
          "name": "punctuation.access.ma",
          "match": "\\."
        },
        {
          "name": "punctuation.separator.colon.ma",
          "match": ":"
        },
        {
          "name": "punctuation.separator.pipe.ma",
          "match": "\\|"
        },
        {
          "name": "punctuation.separator.comma.ma",
          "match": ","
        },
        {
          "name": "punctuation.brackets.ma",
          "match": "[\\(\\)\\{\\}\\[\\]]"
        }
      ]
    },
    "infix_operator": {
      "patterns": [
        {
          "name": "entity.name.infix.operator.ma",
          "match": "#[^#]+#"
        },
        {
          "name": "meta.infix.operation.call.ma",
          "match": "#[^#]+#\\s*(?=\\()"
        }
      ]
    },
    "generics": {
      "patterns": [
        {
          "name": "meta.generic.ma",
          "begin": "\\[",
          "end": "\\]",
          "patterns": [
            {
              "name": "variable.parameter.generic.ma",
              "match": "\\b[A-Za-z_][A-Za-z0-9_]*\\b"
            },
            {
              "name": "keyword.operator.generic.bound.ma",
              "match": ":"
            },
            {
              "name": "keyword.control.impl.ma",
              "match": "\\bimpl\\b"
            },
            {
              "name": "punctuation.separator.generic.ma",
              "match": ","
            },
            {
              "name": "storage.type.arrow.ma",
              "match": "->"
            }
          ]
        }
      ]
    },
    "import_export": {
      "patterns": [
        {
          "name": "meta.import.ma",
          "match": "@import\\s+\"[^\"\\\\]*(?:\\\\.[^\"\\\\]*)*\"",
          "captures": {
            "0": {
              "name": "keyword.control.import.ma"
            }
          }
        }
      ]
    },
    "type_declaration": {
      "patterns": [
        {
          "name": "meta.type.declaration.ma",
          "begin": "(?x)\\btype\\s+([A-Z][A-Za-z0-9_]*)\\s*(?:(:\\s*[A-Za-z0-9_ \\->]+)\\s*)?(\\[.*?\\])?\\s*=\\s*",
          "beginCaptures": {
            "1": {
              "name": "entity.name.type.definition.ma"
            },
            "2": {
              "name": "storage.type.annotation.ma"
            },
            "3": {
              "name": "meta.generic.declaration.ma"
            }
          },
          "end": "(?=^\\s*(?:type|struct|class|let|trait|impl|$))",
          "patterns": [
            {
              "name": "meta.type.variants_block.ma",
              "begin": "(?m)(?<=\\=)\\s*",
              "end": "(?=^\\s*(?:type|struct|class|let|trait|impl|$))",
              "patterns": [
                {
                  "name": "meta.type.variant.ma",
                  "match": "(?m)^[ \\t]*\\|?\\s*([A-Z][A-Za-z0-9_]*)\\s*(?:\\(([^)]*)\\))?\\s*(?:\\:\\s*([^\\n]+))?",
                  "captures": {
                    "1": {
                      "name": "entity.name.type.variant.ma"
                    },
                    "2": {
                      "name": "meta.type.variant.tuple.ma"
                    },
                    "3": {
                      "name": "meta.type.variant.gadt_signature.ma"
                    }
                  }
                },
                {
                  "include": "#generics"
                },
                {
                  "include": "#operators"
                },
                {
                  "include": "#numbers"
                },
                {
                  "include": "#strings"
                }
              ]
            }
          ]
        }
      ]
    },
    "struct_class": {
      "patterns": [
        {
          "name": "meta.struct.or.class.ma",
          "begin": "(?x)\\b(struct|class)\\s+([A-Z][A-Za-z0-9_]*)\\s*(?::\\s*[A-Za-z0-9_ \\->]+\\s*)?(\\[.*?\\])?\\s*(?:=\\s*|\\{)",
          "beginCaptures": {
            "1": {
              "name": "keyword.declaration.ma"
            },
            "2": {
              "name": "entity.name.type.definition.ma"
            },
            "3": {
              "name": "meta.generic.declaration.ma"
            }
          },
          "end": "(?=^\\s*(?:type|struct|class|let|trait|impl|$))",
          "patterns": [
            {
              "name": "meta.struct.field.ma",
              "match": "^[ \\t]*\\|?\\s*(priv\\s+)?([A-Za-z_][A-Za-z0-9_]*)\\s*:\\s*([^\\n,]+)",
              "captures": {
                "1": {
                  "name": "keyword.other.privacy.ma"
                },
                "2": {
                  "name": "variable.other.field.ma"
                },
                "3": {
                  "name": "storage.type.field.ma"
                }
              }
            },
            {
              "name": "meta.struct.const.ma",
              "match": "^[ \\t]*\\|?\\s*([A-Z_][A-Z0-9_]*)\\s*=\\s*([^\\n]+)",
              "captures": {
                "1": {
                  "name": "constant.other.property.ma"
                },
                "2": {
                  "name": "constant.other.value.ma"
                }
              }
            },
            {
              "include": "#generics"
            },
            {
              "include": "#strings"
            },
            {
              "include": "#numbers"
            }
          ]
        }
      ]
    },
    "let_declaration": {
      "patterns": [
        {
          "name": "meta.let.declaration.ma",
          "begin": "(?x)\\blet\\s+([a-z][a-zA-Z0-9_\\-\\#]*)\\b(?:\\s*:\\s*(\\[.*?\\])?\\s*[^=]+)?\\s*=\\s*",
          "beginCaptures": {
            "1": {
              "name": "variable.other.definition.ma"
            },
            "2": {
              "name": "meta.generic.declaration.ma"
            }
          },
          "end": "(?=^\\s*(?:type|struct|class|let|trait|impl|$))",
          "patterns": [
            {
              "include": "#lambda_expression"
            },
            {
              "include": "#function_call"
            },
            {
              "include": "#module_access"
            },
            {
              "include": "#infix_operator"
            },
            {
              "include": "#identifiers"
            },
            {
              "include": "#strings"
            },
            {
              "include": "#numbers"
            }
          ]
        }
      ]
    },
    "lambda_expression": {
      "patterns": [
        {
          "name": "meta.lambda.ma",
          "begin": "(?x)(\\([^()]*\\)|[a-zA-Z_][a-zA-Z0-9_]*)\\s*(?:=>|->)\\s*",
          "beginCaptures": {
            "1": {
              "name": "variable.parameter.ma"
            },
            "0": {
              "name": "keyword.operator.lambda.ma"
            }
          },
          "end": "(?=\\n|$)",
          "patterns": [
            {
              "include": "#identifiers"
            },
            {
              "include": "#operators"
            },
            {
              "include": "#numbers"
            },
            {
              "include": "#strings"
            }
          ]
        }
      ]
    },
    "function_call": {
      "patterns": [
        {
          "name": "meta.function.call.ma",
          "match": "(?x)\\b(?!let\\b|if\\b|match\\b)([a-z][a-zA-Z0-9_]*)\\b\\s*(?:\\[.*?\\])?\\s*(?=\\()",
          "captures": {
            "1": {
              "name": "entity.name.function.call.ma"
            }
          }
        },
        {
          "name": "meta.function.call.infix.ma",
          "match": "#[^#]+#\\s*(?=\\()",
          "captures": {
            "0": {
              "name": "entity.name.function.call.ma"
            }
          }
        }
      ]
    },
    "pattern_matching": {
      "patterns": [
        {
          "name": "meta.match.expression.ma",
          "begin": "\\bmatch\\b",
          "end": "(?=^\\s*(?:type|struct|class|let|trait|impl|$))",
          "patterns": [
            {
              "name": "keyword.control.match.ma",
              "match": "\\bmatch\\b"
            },
            {
              "name": "keyword.control.then.ma",
              "match": "\\bthen\\b"
            },
            {
              "name": "meta.match.case.ma",
              "match": "(?m)^[ \\t]*\\|\\s*([^=|:]+?)\\s*[:=]\\s*",
              "captures": {
                "1": {
                  "name": "variable.parameter.pattern.ma"
                }
              }
            },
            {
              "include": "#identifiers"
            },
            {
              "include": "#numbers"
            },
            {
              "include": "#strings"
            }
          ]
        }
      ]
    },
    "module_access": {
      "patterns": [
        {
          "name": "meta.module.access.ma",
          "match": "(?:[A-Za-z_][A-Za-z0-9_]*::)+[A-Za-z_][A-Za-z0-9_]*|\\b[A-Za-z_][A-Za-z0-9_]*\\s*\\.\\s*\\d+\\b",
          "captures": {
            "0": {
              "name": "variable.other.module.access.ma"
            }
          }
        }
      ]
    },
    "identifiers": {
      "patterns": [
        {
          "name": "entity.name.type.ma",
          "match": "\\b[A-Z][A-Za-z0-9_]*\\b"
        },
        {
          "name": "variable.other.ma",
          "match": "\\b[a-z_][a-zA-Z0-9_\\-]*\\b"
        }
      ]
    }
  }
}